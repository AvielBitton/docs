(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{61:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return d}));var o=t(2),a=t(6),i=(t(0),t(72)),s={id:"high-level-design-fe",title:"High Level Design"},c={unversionedId:"high-level-design-fe",id:"high-level-design-fe",isDocsHomePage:!0,title:"High Level Design",description:"Clean Code",source:"@site/docs/high-level-design-fe.md",permalink:"/docs/docs/",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/high-level-design-fe.md",sidebar:"someSidebar",next:{title:"Nielsen Testing style guide",permalink:"/docs/docs/testing-style-guide"}},l=[{value:"Clean Code",id:"clean-code",children:[{value:"Variables",id:"variables",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Classes",id:"classes",children:[]},{value:"React components",id:"react-components",children:[]},{value:"DRY",id:"dry",children:[]},{value:"KISS",id:"kiss",children:[]},{value:"SOLID",id:"solid",children:[]},{value:"Testing",id:"testing",children:[]},{value:"Error handling",id:"error-handling",children:[]},{value:"Comments",id:"comments",children:[]},{value:"Type script",id:"type-script",children:[]}]},{value:"Keep it simple",id:"keep-it-simple",children:[]},{value:"Where should the business logic reside?",id:"where-should-the-business-logic-reside",children:[]},{value:"Separation of concerns",id:"separation-of-concerns",children:[]},{value:"Compose in Frontend",id:"compose-in-frontend",children:[]},{value:"Functional components over Class components",id:"functional-components-over-class-components",children:[]},{value:"Get data from store only using selectors",id:"get-data-from-store-only-using-selectors",children:[]},{value:"Top-Down / Undirectional Data Flow",id:"top-down--undirectional-data-flow",children:[]},{value:"Typescript patterns",id:"typescript-patterns",children:[]},{value:"Data Provider pattern",id:"data-provider-pattern",children:[]}],r={rightToc:l};function d(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},r,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"clean-code"},"Clean Code"),Object(i.b)("h3",{id:"variables"},"Variables"),Object(i.b)("p",null,"Give meaningful names to variables"),Object(i.b)("h3",{id:"functions"},"Functions"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Function name should describe what it does."),Object(i.b)("li",{parentName:"ol"},"A function should do only one thing."),Object(i.b)("li",{parentName:"ol"},"Limit the amount of function parameters, preferably two. if you need more you can send the parameters inside an object."),Object(i.b)("li",{parentName:"ol"},"If you find yourself writing the same code more than once, even if its a little bit different, try to generalize it in to a function."),Object(i.b)("li",{parentName:"ol"},"Functions should be pure")),Object(i.b)("h3",{id:"classes"},"Classes"),Object(i.b)("h3",{id:"react-components"},"React components"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Make your React component as short as possible"),Object(i.b)("li",{parentName:"ol"},"Name Your Components Using Standard Naming Conventions"),Object(i.b)("li",{parentName:"ol"},"Reduce the number of props to the minimum"),Object(i.b)("li",{parentName:"ol"},"Put Independent Functions Outside of Your Custom Hooks"),Object(i.b)("li",{parentName:"ol"},"Split your components to container and presentational components"),Object(i.b)("li",{parentName:"ol"},"Folderize Your Components")),Object(i.b)("h3",{id:"dry"},"DRY"),Object(i.b)("p",null,'DRY is an acronym that stands for "Don\u2019t Repeat Yourself."\nIf you find yourself writing the same code in different places, consider writing it only once and just reuse it, whether as a function or as a component.'),Object(i.b)("h3",{id:"kiss"},"KISS"),Object(i.b)("p",null,'KISS is an acronym that stands for "Keep it simple stupid."'),Object(i.b)("h3",{id:"solid"},"SOLID"),Object(i.b)("p",null,"Single Responsibility Principle (SRP)\nOpen/Closed Principle (OCP)\nLiskov Substitution Principle (LSP)\nInterface Segregation Principle (ISP)\nDependency Inversion Principle (DIP)"),Object(i.b)("h3",{id:"testing"},"Testing"),Object(i.b)("p",null,"When you write your code, you should write it in a way it would be easy to test it. make your code predictable and testable."),Object(i.b)("h3",{id:"error-handling"},"Error handling"),Object(i.b)("h3",{id:"comments"},"Comments"),Object(i.b)("p",null,"If you write clean code, it should be self commenting."),Object(i.b)("h3",{id:"type-script"},"Type script"),Object(i.b)("h2",{id:"keep-it-simple"},"Keep it simple"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"where-should-the-business-logic-reside"},"Where should the business logic reside?"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"separation-of-concerns"},"Separation of concerns"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"compose-in-frontend"},"Compose in Frontend"),Object(i.b)("p",null,"Composition takes a big place in React's architecture and design.\nWhen building components in React, we usually build them using other components.\nGeneric base components will help us reuse and extend them to higher components without repeating ourselves.\nLets take a Button component for example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Button = ({ onClick, className, children }) => {\n  return (\n    <button onClick={onClick} className={classnames('button', className)}>\n      {children}\n    </button>\n  )\n}\n")),Object(i.b)("p",null,"That's a nice solid base Button.",Object(i.b)("br",{parentName:"p"}),"\n","What do we do when we need to extend it and also have ",Object(i.b)("inlineCode",{parentName:"p"},"PrimaryButton")," and ",Object(i.b)("inlineCode",{parentName:"p"},"SecondaryButton"),"?\nIf we follow the composition pattern, we should do something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const PrimaryButton = ({ onClick, className, children }) => {\n  return (\n    <Button onClick={onClick} className={classnames('primary', className)}>\n      I'm a Primary Button\n    </Button>\n  )\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const SecondaryButton = ({ onClick, className, children }) => {\n  return (\n    <Button onClick={onClick} className={classnames('secondary', className)}>\n      I'm a Secondary Button\n    </Button>\n  )\n}\n")),Object(i.b)("p",null,"A different way to do that is using props to encapsualte that logic within the button.",Object(i.b)("br",{parentName:"p"}),"\n","That way, we don't really compose the base button but extend it, that's not ideal."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Button = ({ onClick, className, children, variant }) => {\n  return (\n    <button\n      onClick={onClick}\n      className={classnames('button', className, {\n        primary: variant === 'primary',\n        secondary: variant === 'secondary'\n      })}\n    >\n      {children}\n    </button>\n  )\n}\n")),Object(i.b)("p",null,"This approach can make our components too big and handle too much logic, that's why we preffer composing over extending."),Object(i.b)("h2",{id:"functional-components-over-class-components"},"Functional components over Class components"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"get-data-from-store-only-using-selectors"},"Get data from store only using selectors"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"top-down--undirectional-data-flow"},"Top-Down / Undirectional Data Flow"),Object(i.b)("p",null,"React's data flow is a one-way data flow (AKA one-way binding), we can use either ",Object(i.b)("inlineCode",{parentName:"p"},"props")," or ",Object(i.b)("inlineCode",{parentName:"p"},"state")," to pass that data.",Object(i.b)("br",{parentName:"p"}),"\n","Usually, the data should be gathered in a top component, and it will pass the data to which of it's children who needs it.",Object(i.b)("br",{parentName:"p"}),"\n",'Having said that, "Lifting state up" and "Co-locating state" are two important issues we need to understand.',Object(i.b)("br",{parentName:"p"}),"\n",'"Lifting state up" means that if we have two child components who consume the same state, this state should be kept on their common parent.',Object(i.b)("br",{parentName:"p"}),"\n",'"Co-locating state" means that if we have a child component consuming state that only it needs, it ',Object(i.b)("strong",{parentName:"p"},"shouldn't")," be kept on the parent component.",Object(i.b)("br",{parentName:"p"}),"\n","We need to remember that every state change on the parent will cause ",Object(i.b)("strong",{parentName:"p"},"all")," of it's children to re-render (unless they bail out of the render process), that's why we should"),Object(i.b)("h2",{id:"typescript-patterns"},"Typescript patterns"),Object(i.b)("p",null,"TBD"),Object(i.b)("h2",{id:"data-provider-pattern"},"Data Provider pattern"),Object(i.b)("p",null,"TBD"))}d.isMDXComponent=!0}}]);