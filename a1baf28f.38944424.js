(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{100:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/e2eDiagram-b9bcee976a1a86a92e5978f57741aa5f.png"},62:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(2),s=n(6),o=(n(0),n(72)),r={id:"testing-style-guide",title:"Nielsen Testing style guide",sidebar_label:"Testing style guide"},i={unversionedId:"testing-style-guide",id:"testing-style-guide",isDocsHomePage:!1,title:"Nielsen Testing style guide",description:"Nielsen Testing Style Guide",source:"@site/docs/testing-style-guide.md",permalink:"/docs/docs/testing-style-guide",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/testing-style-guide.md",sidebar_label:"Testing style guide",sidebar:"someSidebar",previous:{title:"High Level Design",permalink:"/docs/docs/"},next:{title:"High Level Design",permalink:"/docs/docs/high-level-design-be"}},c=[{value:"Basic Rules",id:"basic-rules",children:[]},{value:"Unit Testing",id:"unit-testing",children:[{value:"React Component",id:"react-component",children:[]},{value:"Custom Hooks",id:"custom-hooks",children:[]},{value:"Proper use of <code>Date</code>",id:"proper-use-of-date",children:[]}]},{value:"End-to-end Testing",id:"end-to-end-testing",children:[]},{value:"Find us",id:"find-us",children:[]},{value:"Contributors",id:"contributors",children:[]},{value:"Amendments",id:"amendments",children:[]},{value:"License",id:"license",children:[]}],l={rightToc:c};function b(e){var t=e.components,r=Object(s.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("img",{alt:"Nielsen Testing Style Guide",src:n(99).default}),"\nThis is the Nielsen Marketing Cloud Engineering team's style guide on web front-end testing."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Note"),": The examples in this guide are using the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/"}),"React")," user interface library, in combination with ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://jestjs.io/"}),"Jest")," testing framework. We will share our opinions on different libraries for testing ",Object(o.b)("inlineCode",{parentName:"p"},"React")," components (Like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/testing-library/react-testing-library"}),"react-testing-library")," which we also use for examples). For End-to-end testing we use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.cypress.io/"}),"Cypress"),". However, we believe that our suggested approach could be well used with other frameworks/libraries with some slight adjustments")),Object(o.b)("h2",{id:"basic-rules"},"Basic Rules"),Object(o.b)("h4",{id:"aaa-pattern---arrange-act-assert"},"AAA Pattern - Arrange Act Assert"),Object(o.b)("p",null,"We should structure our tests by the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://wiki.c2.com/?ArrangeActAssert"}),"AAA pattern"),", containing a visual separation between each block.\nThis will allow the reader to spend no time to figure out how our test works."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Arrange: All the setup needed to happen to bring the system to the scenario the test aims to simulate. Adding DB records, mocking functions, creating objects and any other preperation your test needs."),Object(o.b)("li",{parentName:"ul"},"Act: Execute the unit under the test. This step usually contains one line of code."),Object(o.b)("li",{parentName:"ul"},"Assert: Ensure the received value satisfies the expectation.\nThis step usually contains one test ",Object(o.b)("strong",{parentName:"li"},"concept"),". It may include more than one assertion.")),Object(o.b)("p",null,"Example component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"function SearchBox({ value, onChange, disabled }) {\n   return (\n        <input\n            placeholder='Search'\n            onChange={onChange}\n            value={value}\n            disabled={diabled}/>\n    );\n}\n")),Object(o.b)("p",null,"\u2705 Do - Follow the AAA pattern and have visible separations between each block:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('SearchBox: Should not call onChange when input is disabled', () => {\n  const onChange = jest.fn()\n  const {getByPlaceholder} = render(<SearchBox\n                                        value=''\n                                        onChange={onChange}\n                                        disabled/>)\n  const domInput = getByPlaceholder('Search')\n\n  fireEvent.change(domInput, { target: { value: '23' } })\n\n  expect(onChange).toHaveBeenCalledTimes(0)\n  expect(domInput.value).toBe('')\n})\n")),Object(o.b)("p",null,"\u274c Don't - Write in one block. It's harder to interpret and understand without diving into the code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('SearchBox: Should not call onChange when input is disabled', () => {\n  const onChange = jest.fn()\n  const {getByPlaceholder} = render(<SearchBox\n                                        value=''\n                                        onChange={onChange}\n                                        disabled/>)\n  const domInput = getByPlaceholder('Search')\n  fireEvent.change(domInput, { target: { value: '23' } })\n  expect(onChange).toHaveBeenCalledTimes(0)\n  expect(domInput.value).toBe('')\n})\n")),Object(o.b)("h5",{id:"act-in-react"},"Act in React"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"When writing UI tests, tasks like rendering, user events, or data fetching can be considered as \u201cunits\u201d of interaction with a user interface. ",Object(o.b)("inlineCode",{parentName:"p"},"React")," provides a helper called act() that makes sure all updates related to these \u201cunits\u201d have been processed and applied to the DOM before you make any assertions")),Object(o.b)("p",null,"Simply put, if you render or interact with an element, you need to wrap the code that may cause side-effects inside an act function.\nThe goal is to make your test run closer to what real users would experience.\nIf you feel like wrapping every interaction you make with ",Object(o.b)("inlineCode",{parentName:"p"},"act")," is an overhead, you can use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://testing-library.com/docs/react-testing-library/intro"}),"React-Testing-Library")," which already wraps interactions with ",Object(o.b)("inlineCode",{parentName:"p"},"act")," for you."),Object(o.b)("p",null,"Example Component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"})," function App() {\n   let [counter, setCounter] = useState(0);\n   useEffect(() => {\n     setCounter(1);\n   }, []);\n   return counter;\n }\n")),Object(o.b)("p",null,"\u2705 Do - Wrap your interactions with ",Object(o.b)("inlineCode",{parentName:"p"},"act")," to guarantee that any state updates and enqueued effects will be executed:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'test("should render 1", () => {\n  const el = document.createElement("div");\n  act(() => {\n    ReactDOM.render(<App />, el);\n  });\n  expect(el.innerHTML).toBe("1"); // this passes!\n});\n')),Object(o.b)("p",null,"\u274c Don't - Interact without wrapping your interaction with ",Object(o.b)("inlineCode",{parentName:"p"},"act"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'test("should render 1", () => {\n  const el = document.createElement("div");\n  ReactDOM.render(<App />, el);\n  expect(el.innerHTML).toBe("1"); // this fails!\n});\n')),Object(o.b)("h5",{id:"async-side-effects-in-react"},"Async side effects in react"),Object(o.b)("p",null,"If your component triggers an XHR (in ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," for example), you will want to wait for an answer (even when mocking APIs).\nWrapping your ",Object(o.b)("inlineCode",{parentName:"p"},"render")," with ",Object(o.b)("inlineCode",{parentName:"p"},"act")," won't do it in this case. In order to test your component with data, we suggest to mock the request and wait for the data to be shown on the screen."),Object(o.b)("p",null,"Example component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"})," function UsersList({getUsers, users = [], isFetching}) {\n   useEffect(() => {\n     getUsers();\n   }, []);\n   return isFetching ?\n        (\n            <div>Loading...</div>\n        ) :\n        (\n            <>\n                <div>Users:</div>\n                {\n                    users.map(currUser => (\n                        <div\n                            key={currUser.id}\n                            role='listitem'>\n                                {currUser.name}\n                        </div>\n                    )\n                }\n            </>\n        );\n }\n")),Object(o.b)("p",null,"\u2705 Do - Wait for an element to appear when waiting for an XHR request to finish:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test(\"should render 3 users\", () => {\n    // React-Testing-Library wraps act with render\n    render(<App />);\n\n    await waitForElement(() => getByText('Users:'));\n    expect(getByRole('listitem')).toHaveLength(3); // this passes\n});\n")),Object(o.b)("p",null,"\u274c Don't - Query the DOM without waiting for an indication that the async operation has finished:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test(\"should render 1\", () => {\n    // React-Testing-Library wraps act with render\n    render(<App />);\n    expect(getByRole('listitem')).toHaveLength(3); // this fails\n});\n")),Object(o.b)("h2",{id:"unit-testing"},"Unit Testing"),Object(o.b)("h3",{id:"react-component"},"React Component"),Object(o.b)("p",null,"We strongly encourage testing components' behavior rather than testing their implementation details. What does it mean? Generally, testing the behavior means making assertions about the outcome of a desired action, rather than asserting about the way the component achieved this outcome internally."),Object(o.b)("p",null,"This means we can rewrite/refactor a component implementation and have its tests remain the same and not break.\nIf the test is tied to the way the component is implemented (e.g. by calling an internal function directly), changes in the implementation (e.g. renaming that function) would break the test even though the component still behaves the same."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Note"),": Using ",Object(o.b)("inlineCode",{parentName:"p"},"React Testing Library")," helps us avoid writing implementation details tests, as opposed to ",Object(o.b)("inlineCode",{parentName:"p"},"Enzyme")," where it's much easier to test implementation details unintentionally.")),Object(o.b)("h4",{id:"hooks-component"},"Hooks Component"),Object(o.b)("p",null,"React hooks components are great to show why behavior testing is the way to go. The reason for it is that until lately we were used to only write class components, which are easy to test using implementation details tests.\nThis testing pattern will need change drastically in order to fit new functional components using hooks."),Object(o.b)("p",null,"The following example demonstrates exactly how implementation details tests break easily, while behavior tests continue working even after the switch to React hooks."),Object(o.b)("p",null,"Here is a simple class component, rendering a button and a click counter:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"export class ClickCounterClass extends React.Component {\n    state = {\n      count: 0\n    }\n    render() {\n      return (\n        <div>\n          <p data-testid='counter-value'>{this.state.count}</p>\n          <button data-testid='counter-button' onClick={() => this.setState(({count}) => ({count: count + 1}))}>\n            Click me\n          </button>\n        </div>\n      );\n    }\n  }\n")),Object(o.b)("p",null,"And here is a functional component that does the same thing using the ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hook:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"export const ClickCounterHooks = () => {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <p data-testid='counter-value'>{count}</p>\n      <button data-testid='counter-button' onClick={() => setCount(count => count + 1)}>\n          Click Me\n      </button>\n    </div>\n  )\n}\n")),Object(o.b)("p",null,"And now, lets test the outcome of clicking the button:"),Object(o.b)("p",null,"\u2705 Do - Test the behavior. Make an assertion about the actual DOM element that we expect to change as a result of the click:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('shows the correct amount of clicks', () => {\n  const testMessage = 'Test Message'\n  const { queryByText, getByTestId } = render(<ClickCounterClass />)\n  \n  fireEvent.click(getByTestId('counter-button'))\n  \n  expect(getByTestId('counter-value').textContent).toBe('1')\n})\n")),Object(o.b)("p",null,"The above test will pass both if we render ",Object(o.b)("inlineCode",{parentName:"p"},"<ClickCounterClass />")," or if we render ",Object(o.b)("inlineCode",{parentName:"p"},"<ClickCounterHooks />")),Object(o.b)("p",null,"\u274c Don't - Make assertions about details in the component's implemantation. They will eventually change and will wrongly cause the test to fail:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('Shows the correct amount of clicks', () => {\n  const wrapper = shallow(<ClickCounterClass />)\n\n  wrapper.find('button').simulate('click')\n\n  expect(wrapper.instance().state.count).to.equal(1)\n})\n")),Object(o.b)("p",null,"This above \"Don't\" example uses Enzyme's ",Object(o.b)("inlineCode",{parentName:"p"},"shallow()")," and ",Object(o.b)("inlineCode",{parentName:"p"},"wrapper.instance()"),". It asserts about the 'count' prop in the state which is an implementation detail.\nThis test passes when we render ",Object(o.b)("inlineCode",{parentName:"p"},"<ClickCounterClass />"),", but it fails when we change it to render ",Object(o.b)("inlineCode",{parentName:"p"},"<ClickCounterHooks />")),Object(o.b)("h4",{id:"class-component"},"Class Component"),Object(o.b)("p",null,"When testing the async functionality of a ",Object(o.b)("inlineCode",{parentName:"p"},"Class Component"),", we want to ensure that our side effect finished running before asserting.\nThis is important because we should only assert after we are sure all changes to the DOM were made.\nWe should also focus on testing the component functionality instead of testing it's implementation details. That way our tests are maintainable and insure, with high confidence, that are components behave as they should."),Object(o.b)("p",null,"Example Login component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'class Login extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      resolved: false,\n      error: null\n    };\n  }\n\n  handleSubmit = async(event) => {\n    event.preventDefault();\n    const { username, password } = event.target.elements;\n    this.setState({ resolved: false, error: null });\n    try{\n        await login(username, password);\n        this.setState({ resolved: true, error: null });\n    } catch (error) {\n        this.setState({ resolved: false, error: error.message});\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label htmlFor="username">Username</label>\n            <input id="username" />\n          </div>\n          <div>\n            <label htmlFor="password">Password</label>\n            <input id="password" type="password" />\n          </div>\n          <button type="submit">Login</button>\n        </form>\n        {this.state.error ? (\n          <div role="alert">{this.state.error.message}</div>\n        ) : null}\n        {this.state.resolved && <div role="alert">Congrats! You\'re in!</div>}\n      </div>\n    );\n  }\n}\n')),Object(o.b)("p",null,"\u2705 Do - Make sure to wait for the side effect to finish before selecting elements on the DOM and making assertions:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('allows the user to login successfully', async () => {\n  jest.spyOn(window, 'login').mockImplementationOnce(() => {\n    return Promise.resolve({})\n  })\n  const {getByLabelText, getByText, findByRole} = render(<Login />)\n\n  fireEvent.change(getByLabelText(/username/i), {target: {value: 'chuck'}})\n  fireEvent.change(getByLabelText(/password/i), {target: {value: 'norris'}})\n  fireEvent.click(getByText(/submit/i))\n\n  // wait for the side effect to finish before selecting elements on the dom\n  const alert = await findByRole('alert')\n  expect(alert).toHaveTextContent(/congrats/i)\n})\n")),Object(o.b)("p",null,"\u274c Don't - Select a DOM element without waiting for the side effect to finish. You might miss changes to the DOM:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('allows the user to login successfully', async () => {\n  jest.spyOn(window, 'login').mockImplementationOnce(() => {\n    return Promise.resolve({})\n  })\n  const {getByLabelText, getByText, findByRole} = render(<Login />)\n\n  fireEvent.change(getByLabelText(/username/i), {target: {value: 'chuck'}})\n  fireEvent.change(getByLabelText(/password/i), {target: {value: 'norris'}})\n  fireEvent.click(getByText(/submit/i))\n\n  // Selecting a dom element without waiting for the side effect to finish is wrong!\n  const alert = findByRole('alert')\n  expect(alert).toHaveTextContent(/congrats/i)\n})\n")),Object(o.b)("p",null,"\u274c Don't - Test state changes, as it is an implementation detail. That way refactoring your component might break your tests:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('allows the user to login successfully', async () => {\n  jest.spyOn(window, 'login').mockImplementationOnce(() => {\n    return Promise.resolve({})\n  })\n\n  const wrapper = mount(<Login/>)\n\n  wrapper.find('#username').simulate('change', {target: {value: 'chuck'})\n  wrapper.find('#password').simulate('change', {target: {value: 'norris'})\n  wrapper.find('button[type=\\\"submit\\\"]').simulate('click')\n\n  await new Promise(resolve => setImmediate(resolve))\n\n  expect(wrapper.find('role=\\\"alert\\\"')).toContain('congrats')\n\n  // Implementation detail, shouldn't be tested!\n  expect(wrapper.state('resolved')).toBeTruthy()\n})\n")),Object(o.b)("p",null,"\u274c Don't - Use native element selectors, as it is also an implementation detail:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('login - implementation details', async () => {\n  jest.spyOn(window, 'login').mockImplementationOnce(() => {\n    return Promise.resolve({})\n  })\n\n  const wrapper = mount(<Login/>)\n\n  // Implementation detail, shouldn't be tested!\n  expect(wrapper.find('input[type=\\\"text\\\"]').length).toBe(1)\n  expect(wrapper.find('input[type=\\\"password\\\"]').length).toBe(1)\n})\n")),Object(o.b)("h4",{id:"redux-connected-component"},"Redux Connected Component"),Object(o.b)("p",null,"When testing the integration between a ",Object(o.b)("inlineCode",{parentName:"p"},"Connected Component")," and its ",Object(o.b)("inlineCode",{parentName:"p"},"React Component"),", we want to ensure that any change in the ",Object(o.b)("inlineCode",{parentName:"p"},"React Component")," interface (i.e. props) will cause the tests to fail.\nThe idea is to create a small compatability test between a ",Object(o.b)("inlineCode",{parentName:"p"},"React Component")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Connected Component")," (which connects it with redux)."),Object(o.b)("p",null,"We want to avoid testing ",Object(o.b)("inlineCode",{parentName:"p"},"mapStateToProps"),"/",Object(o.b)("inlineCode",{parentName:"p"},"mapDispatchToProps")," isolated! In this case your test will pass even if the ",Object(o.b)("inlineCode",{parentName:"p"},"React Component")," props have changed."),Object(o.b)("p",null,"Example redux connected component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const CounterComponent = ({ counter, increment, decrement }) => (\n  <div>\n    <button onClick={increment}>incrementBtn</button>\n    <button onClick={decrement}>decrementBtn</button>\n    <div data-testid="counter-element">{counter}</div>\n  </div>\n)\n\nconst mapStateToProps = state => ({\n  counter: getCounterSelector(state)\n})\n\nconst mapDispatchToProps = dispatch =>\n  bindActionCreators({ increment, decrement }, dispatch)\n\nconst ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(CounterComponent)\n')),Object(o.b)("p",null,"\u2705 Do - Mock the action creators, and assert the expected actions to have been called:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"import { increment, decrement } from '..'\njest.mock('./MockActionCreators') // mock increment and decrement action creators\n\ndescribe('redux connected component unit-test', () => {\n  test('should integrate safe', () => {\n    const { getByTestId, queryByText } = render(\n      <Provider store={configureStore()}>\n        <ConnectedComponent />\n      </Provider>\n    )\n\n    fireEvent.click(queryByText('incrementBtn'))\n\n    expect(increment).toHaveBeenCalledTimes(1)\n  })\n})\n")),Object(o.b)("p",null,"\u274c Don't - Test the results of firing the redux action. This should be tested separately in dedicated reducer tests:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"describe('redux connected component unit-test', () => {\n  test('should integrate safe', () => {\n      const { getByTestId, queryByText } = render(\n        <Provider store={configureStore()}>\n          <ConnectedComponent />\n        </Provider>\n      )\n\n      fireEvent.click(queryByText('incrementBtn'))\n\n      expect(getByTestId('counter-element').textContent).toBe('1')\n  })\n})\n")),Object(o.b)("h3",{id:"custom-hooks"},"Custom Hooks"),Object(o.b)("p",null,"Sometimes, we need to create custom hooks that encapsulate relevant logic for multiple developers on our team."),Object(o.b)("p",null,"If these hooks can be easily tested by testing a component that uses them, we prefer doing that, in order to keep with the behavioral testing approach.\nIf that's not the case, we encounter a problem where a hook can only be called inside the body of a functional component.\nTo test these cases, we use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-hooks-testing-library.com/"}),"react-hooks-testing-library")),Object(o.b)("p",null,"Lets take a ",Object(o.b)("inlineCode",{parentName:"p"},"useToggle")," hook example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const useToggle = (initialValue) => {\n  const [isOn, setIsOn] = useState(initialValue)\n  const open = () => {\n    setIsOn(true)\n  }\n  const close = () => {\n    setIsOn(false)\n  }\n  const toggle = () => {\n    setIsOn(prevIsOn => !prevIsOn)\n  }\n  return [isOn, toggle, open, close]\n}\n")),Object(o.b)("p",null,"Testing it using ",Object(o.b)("inlineCode",{parentName:"p"},"react-hooks-testing-library")," should look like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"test('should toggle state on off', () => {\n  const { result } = renderHook(() => useToggle(false))\n\n  act(() => {\n    const [, toggle] = result.current\n    toggle()\n  })\n\n  const [isOpen] = result.current\n  expect(isOpen).toBe(true)\n})\n")),Object(o.b)("p",null,"Don't forget to wrap every interaction with ",Object(o.b)("inlineCode",{parentName:"p"},"act"),", so after the interaction finishes, you'll get the updated value!"),Object(o.b)("h3",{id:"proper-use-of-date"},"Proper use of ",Object(o.b)("inlineCode",{parentName:"h3"},"Date")),Object(o.b)("p",null,"We want to mock the ",Object(o.b)("inlineCode",{parentName:"p"},"Date")," object itself, this way we know for sure that we will get the exact result for the given date any time. In addition, we ensure that our current timestamp will always return the same result instead of creating a new timestamp every test, which could lead to false negatives."),Object(o.b)("p",null,"\u2705 Do - mock the ",Object(o.b)("inlineCode",{parentName:"p"},"Date")," object, not the libraries that use it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const DATE_TO_USE = new Date('2018\u201301\u201330T12:34:56+00:00')\nconst _Date = new Date()\n\nbeforeAll(()=> {\n    global.Date = jest.fn(()=> DATE_TO_USE)\n    // Date methods\n    global.Date.UTC = _Date.UTC\n    global.Date.now = _Date.now\n})\n\nafterAll(()=> {\n    global.Date = _Date\n})\n")),Object(o.b)("p",null,"\u274c Don't - mock external libraries that use the ",Object(o.b)("inlineCode",{parentName:"p"},"Date")," object:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// mocking moment.js for example\njest.mock('moment', ()=> ({\n    // moment methods that you need\n}))\n")),Object(o.b)("h2",{id:"end-to-end-testing"},"End-to-end Testing"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"For End-to-end testing we use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.cypress.io/"}),"Cypress")," Framework. However, our suggested concepts could be adopted with other End-to-End frameworks/test runners. ")),Object(o.b)("p",null,"The below diagram illustrates main blocks that involved in End-to-end test: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#test"}),"Test"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#page-object"}),"Page Object"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#flow"}),"Flow")),Object(o.b)("p",null,Object(o.b)("img",{alt:"End-to-end Test diagram",src:n(100).default})),Object(o.b)("h5",{id:"page-object"},"Page Object"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Responsible to encapsulate technical details (like css selectors, data attributes, etc`) to access and manipulate the elements of the tested application page"),Object(o.b)("li",{parentName:"ul"},"Provides an API for atomic interaction with the tested application page. This API is used by ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#test"}),"Test")," "),Object(o.b)("li",{parentName:"ul"},"Has no assertions"),Object(o.b)("li",{parentName:"ul"},"Can use another Page Object, it depends on the hierarchical structure of application pages "),Object(o.b)("li",{parentName:"ul"},"Can optionally use ",Object(o.b)("em",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"em"},"Selectors"))," module, that contains reusable css selectors definitions"),Object(o.b)("li",{parentName:"ul"},"Complex shared components should expose Page Objects for other consumers"),Object(o.b)("li",{parentName:"ul"},"You can refer ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://martinfowler.com/bliki/PageObject.html"}),"this article")," for more information about Page Object")),Object(o.b)("p",null,"Example of Page Object:    "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"class TestPageObject {\n  \n  getSearchInput () {\n    return cy.get('[data-test-id=\"search-input\"]')\n  }\n\n  typeSearchTerm (searchTerm) {\n    this.getSearchInput().type(searchTerm)\n  }\n  \n  getSearchResults () {\n    return cy.get('[data-test-id=\"search-results-table\"]')\n  }\n}\n")),Object(o.b)("h5",{id:"flow"},"Flow"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Common reusable logic that can be shared between tests (i.e login flow)"),Object(o.b)("li",{parentName:"ul"},"Uses one or more ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#page-object"}),"Page Objects")," under the hood"),Object(o.b)("li",{parentName:"ul"},"Has no assertions")),Object(o.b)("h5",{id:"test"},"Test"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Uses the ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#aaa-pattern---arrange-act-assert"}),"AAA pattern")),Object(o.b)("li",{parentName:"ul"},"One and only one unit that ",Object(o.b)("strong",{parentName:"li"},"has assertions")," for testing components' integration and data integrity "),Object(o.b)("li",{parentName:"ul"},"Uses one or more ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#page-object"}),"Page Objects")," to access and interact with tested application page"),Object(o.b)("li",{parentName:"ul"},"Uses one or more ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#flow"}),"Flows")," to implement ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#aaa-pattern---arrange-act-assert"}),'"Act"')," part of the test")),Object(o.b)("p",null,"Here is a simple example of test that checks search data functionality and uses 'TestPageObject':    "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"import TestPageObject from './TestPageObject'\nconst testPageObject =  new TestPageObject()\n\nit('should search data correctly', () => {\n  \n  testPageObject.typeSearchTerm('searchTerm')\n  \n  testPageObject.getSearchResults().should('contain', 'searchTerm')\n})\n")),Object(o.b)("h2",{id:"find-us"},"Find us"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"We have a Tech Blog! You can find it at ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://medium.com/nmc-techblog"}),"Medium"),".")),Object(o.b)("h2",{id:"contributors"},"Contributors"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/nielsen-oss/docs/graphs/contributors"}),"Contributors"))),Object(o.b)("h2",{id:"amendments"},"Amendments"),Object(o.b)("p",null,"Feel free to submit pull requests and contribute to this style guide!"),Object(o.b)("h2",{id:"license"},"License"),Object(o.b)("p",null,"(Apache License 2.0)"),Object(o.b)("p",null,"Copyright (c) 2020 Nielsen"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},Object(o.b)("a",Object(a.a)({parentName:"strong"},{href:"#nielsen-testing-style-guide"}),"\u2b06 back to top"))))}b.isMDXComponent=!0},99:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/logo-a1c3782d096aa13dc6874da7eef26a89.png"}}]);